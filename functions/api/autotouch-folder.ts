// AutoTouch folder structure generator
// Creates a ZIP that users can extract to create .at folder

export async function createAutoTouchFolder(device_hash: string): Promise<ArrayBuffer> {
  console.log('üìÅ Creating AutoTouch folder structure for extraction')

  // Lua scripts for AutoTouch
  const mainLua = `-- SMARTGRAM AutoTouch Script
-- Device: ${device_hash}
-- Generated by SMARTGRAM

-- Main entry point
function main()
    print("SMARTGRAM AutoTouch Script Starting...")
    print("Device Hash: ${device_hash}")

    -- Simple automation demo
    toast("SMARTGRAM Script Loaded!", 2)

    -- Wait 2 seconds
    mSleep(2000)

    -- Demo actions
    print("Performing demo actions...")

    -- Example touch (adjust coordinates for your needs)
    -- tap(100, 200)
    -- mSleep(1000)

    toast("Demo Complete! Modify this script for your automation.", 3)
    print("Script execution completed successfully")
end

-- Execute main function
main()
`

  const configLua = `-- SMARTGRAM Configuration
-- Device specific settings

local config = {
    device_hash = "${device_hash}",
    version = "1.0.0",
    author = "SMARTGRAM",

    -- Automation settings
    delay_between_actions = 1000,  -- milliseconds
    max_retries = 3,
    timeout = 30000,  -- 30 seconds

    -- Screen settings (adjust for your device)
    screen_width = 375,   -- iPhone screen width
    screen_height = 812,  -- iPhone screen height
}

return config
`

  const utilsLua = `-- SMARTGRAM Utilities
-- Common functions for automation

local utils = {}

-- Safe tap with error handling
function utils.safe_tap(x, y, duration)
    duration = duration or 100

    if x and y then
        print("Tapping at: " .. x .. ", " .. y)
        tap(x, y)
        mSleep(duration)
        return true
    else
        print("Invalid tap coordinates")
        return false
    end
end

-- Safe swipe with error handling
function utils.safe_swipe(x1, y1, x2, y2, duration)
    duration = duration or 500

    if x1 and y1 and x2 and y2 then
        print("Swiping from: " .. x1 .. ", " .. y1 .. " to: " .. x2 .. ", " .. y2)
        swipe(x1, y1, x2, y2, duration)
        return true
    else
        print("Invalid swipe coordinates")
        return false
    end
end

-- Wait for UI element (placeholder - requires actual implementation)
function utils.wait_for_element(element_name, timeout)
    timeout = timeout or 10000
    print("Waiting for element: " .. element_name .. " (timeout: " .. timeout .. "ms)")

    -- This is a placeholder - actual implementation would use AutoTouch's
    -- findImage or findColor functions
    mSleep(1000)
    return true
end

-- Show status message
function utils.show_status(message, duration)
    duration = duration or 2
    print("Status: " .. message)
    toast(message, duration)
end

return utils
`

  // Create file entries
  const entries = [
    { path: 'main.lua', content: mainLua },
    { path: 'config.lua', content: configLua },
    { path: 'utils.lua', content: utilsLua }
  ]

  // Create standard ZIP
  let zipData = new Uint8Array(0)
  let currentOffset = 0
  const fileEntries: Array<{
    path: string
    content: Uint8Array
    crc32: number
    localOffset: number
  }> = []

  // CRC32 calculation
  function calculateCRC32(data: Uint8Array): number {
    const table = new Array(256)
    for (let i = 0; i < 256; i++) {
      let crc = i
      for (let j = 0; j < 8; j++) {
        crc = (crc & 1) ? (0xEDB88320 ^ (crc >>> 1)) : (crc >>> 1)
      }
      table[i] = crc
    }

    let crc = 0xFFFFFFFF
    for (let i = 0; i < data.length; i++) {
      crc = table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8)
    }
    return (crc ^ 0xFFFFFFFF) >>> 0
  }

  // Process each file
  for (const entry of entries) {
    const fileBytes = new TextEncoder().encode(entry.content)
    const crc32 = calculateCRC32(fileBytes)

    // Create local file header
    const filenameBytes = new TextEncoder().encode(`smartgram/${entry.path}`)
    const localHeader = new Uint8Array(30 + filenameBytes.length)
    const headerView = new DataView(localHeader.buffer)

    let offset = 0

    // Local file header signature
    headerView.setUint32(offset, 0x04034b50, true) // PK\x03\x04
    offset += 4

    // Version needed (2.0)
    headerView.setUint16(offset, 20, true)
    offset += 2

    // General purpose bit flag (0x0800 = UTF-8)
    headerView.setUint16(offset, 0x0800, true)
    offset += 2

    // Compression method (0 = stored)
    headerView.setUint16(offset, 0, true)
    offset += 2

    // Last mod time & date
    const now = new Date()
    const dosTime = ((now.getHours() << 11) | (now.getMinutes() << 5) | (now.getSeconds() >> 1))
    const dosDate = (((now.getFullYear() - 1980) << 9) | ((now.getMonth() + 1) << 5) | now.getDate())
    headerView.setUint16(offset, dosTime, true)
    offset += 2
    headerView.setUint16(offset, dosDate, true)
    offset += 2

    // CRC-32
    headerView.setUint32(offset, crc32, true)
    offset += 4

    // Compressed size
    headerView.setUint32(offset, fileBytes.length, true)
    offset += 4

    // Uncompressed size
    headerView.setUint32(offset, fileBytes.length, true)
    offset += 4

    // Filename length
    headerView.setUint16(offset, filenameBytes.length, true)
    offset += 2

    // Extra field length
    headerView.setUint16(offset, 0, true)
    offset += 2

    // Filename
    localHeader.set(filenameBytes, offset)

    // Combine header + file data
    const totalSize = localHeader.length + fileBytes.length
    const newZipData = new Uint8Array(zipData.length + totalSize)
    newZipData.set(zipData)
    newZipData.set(localHeader, zipData.length)
    newZipData.set(fileBytes, zipData.length + localHeader.length)
    zipData = newZipData

    fileEntries.push({
      path: `smartgram/${entry.path}`,
      content: fileBytes,
      crc32,
      localOffset: currentOffset
    })

    currentOffset += totalSize
    console.log(`‚úÖ Added: ${entry.path} (${fileBytes.length} bytes)`)
  }

  // Create central directory
  const centralDirectoryOffset = zipData.length
  let centralDirectorySize = 0

  for (const entry of fileEntries) {
    const filenameBytes = new TextEncoder().encode(entry.path)
    const centralHeader = new Uint8Array(46 + filenameBytes.length)
    const centralView = new DataView(centralHeader.buffer)

    let offset = 0

    // Central file header signature
    centralView.setUint32(offset, 0x02014b50, true)
    offset += 4

    // Version made by (Unix)
    centralView.setUint16(offset, 0x031E, true)
    offset += 2

    // Version needed to extract
    centralView.setUint16(offset, 20, true)
    offset += 2

    // General purpose bit flag
    centralView.setUint16(offset, 0x0800, true)
    offset += 2

    // Compression method
    centralView.setUint16(offset, 0, true)
    offset += 2

    // Last mod time & date
    const now = new Date()
    const dosTime = ((now.getHours() << 11) | (now.getMinutes() << 5) | (now.getSeconds() >> 1))
    const dosDate = (((now.getFullYear() - 1980) << 9) | ((now.getMonth() + 1) << 5) | now.getDate())
    centralView.setUint16(offset, dosTime, true)
    offset += 2
    centralView.setUint16(offset, dosDate, true)
    offset += 2

    // CRC-32
    centralView.setUint32(offset, entry.crc32, true)
    offset += 4

    // Compressed size
    centralView.setUint32(offset, entry.content.length, true)
    offset += 4

    // Uncompressed size
    centralView.setUint32(offset, entry.content.length, true)
    offset += 4

    // Filename length
    centralView.setUint16(offset, filenameBytes.length, true)
    offset += 2

    // Extra field length
    centralView.setUint16(offset, 0, true)
    offset += 2

    // File comment length
    centralView.setUint16(offset, 0, true)
    offset += 2

    // Disk number start
    centralView.setUint16(offset, 0, true)
    offset += 2

    // Internal file attributes
    centralView.setUint16(offset, 0, true)
    offset += 2

    // External file attributes (Unix file permissions)
    centralView.setUint32(offset, 0x81A40000, true)
    offset += 4

    // Relative offset of local header
    centralView.setUint32(offset, entry.localOffset, true)
    offset += 4

    // Filename
    centralHeader.set(filenameBytes, offset)

    // Append to ZIP
    const newZipData = new Uint8Array(zipData.length + centralHeader.length)
    newZipData.set(zipData)
    newZipData.set(centralHeader, zipData.length)
    zipData = newZipData

    centralDirectorySize += centralHeader.length
  }

  // End of central directory record
  const endRecord = new Uint8Array(22)
  const endView = new DataView(endRecord.buffer)

  endView.setUint32(0, 0x06054b50, true) // Signature
  endView.setUint16(4, 0, true) // This disk number
  endView.setUint16(6, 0, true) // Central directory start disk
  endView.setUint16(8, fileEntries.length, true) // Entries this disk
  endView.setUint16(10, fileEntries.length, true) // Total entries
  endView.setUint32(12, centralDirectorySize, true) // Central directory size
  endView.setUint32(16, centralDirectoryOffset, true) // Central directory offset
  endView.setUint16(20, 0, true) // Comment length

  // Final ZIP
  const finalZipData = new Uint8Array(zipData.length + endRecord.length)
  finalZipData.set(zipData)
  finalZipData.set(endRecord, zipData.length)

  console.log(`‚úÖ AutoTouch folder structure created: ${finalZipData.length} bytes`)

  return finalZipData.buffer
}

// Handler for AutoTouch folder generation
export async function handleAutoTouchFolder(request: Request, env: any): Promise<Response> {
  console.log('üìÅ AutoTouch folder structure generation requested')

  try {
    const body = await request.json() as { device_hash: string }
    const { device_hash } = body

    if (!device_hash) {
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Device hash is required'
        }),
        {
          status: 400,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
          }
        }
      )
    }

    console.log(`üì± Generating AutoTouch folder for device: ${device_hash}`)

    const folderBuffer = await createAutoTouchFolder(device_hash)

    console.log(`‚úÖ Sending folder ZIP: ${folderBuffer.byteLength} bytes`)

    return new Response(folderBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/zip',
        'Content-Disposition': 'attachment; filename="smartgram-folder.zip"',
        'Access-Control-Allow-Origin': '*'
      }
    })

  } catch (error) {
    console.error('‚ùå Folder generation error:', error)
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      }),
      {
        status: 500,
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*'
        }
      }
    )
  }
}