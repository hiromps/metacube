// Simple AutoTouch .at package generator (non-encrypted)
// Creates standard ZIP package that AutoTouch can encrypt to .ate

export interface SimpleATEntry {
  name: string
  content: string
}

export async function createSimpleAT(device_hash: string): Promise<ArrayBuffer> {
  console.log('üì¶ Creating simple .at package for AutoTouch encryption')

  // Simple test scripts
  const workerContent = `-- AutoTouch Worker Script
-- Device: ${device_hash}
-- Generated by SMARTGRAM

print("Worker script initialized")
print("Device hash: ${device_hash}")

-- Simple automation example
function automate()
    print("Starting automation...")
    -- Add your automation logic here
    toast("Automation complete!", 2)
end

-- Export function
return { automate = automate }
`

  const indexContent = `-- AutoTouch Index Script
-- Main entry point

print("Index script loaded")
local worker = require("worker")

-- Execute automation
worker.automate()

print("Script execution complete")
`

  const entries: SimpleATEntry[] = [
    { name: 'worker.js', content: workerContent },
    { name: 'index.js', content: indexContent }
  ]

  // Create standard ZIP (non-encrypted)
  let zipData = new Uint8Array(0)
  let currentOffset = 0
  const fileEntries: Array<{
    name: string
    content: Uint8Array
    crc32: number
    localOffset: number
  }> = []

  // CRC32 calculation
  function calculateCRC32(data: Uint8Array): number {
    const table = new Array(256)
    for (let i = 0; i < 256; i++) {
      let crc = i
      for (let j = 0; j < 8; j++) {
        crc = (crc & 1) ? (0xEDB88320 ^ (crc >>> 1)) : (crc >>> 1)
      }
      table[i] = crc
    }

    let crc = 0xFFFFFFFF
    for (let i = 0; i < data.length; i++) {
      crc = table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8)
    }
    return (crc ^ 0xFFFFFFFF) >>> 0
  }

  // Process each file
  for (const entry of entries) {
    const fileBytes = new TextEncoder().encode(entry.content)
    const crc32 = calculateCRC32(fileBytes)

    // Create local file header (standard ZIP, no encryption)
    const filenameBytes = new TextEncoder().encode(entry.name)
    const localHeader = new Uint8Array(30 + filenameBytes.length)
    const headerView = new DataView(localHeader.buffer)

    let offset = 0

    // Local file header signature
    headerView.setUint32(offset, 0x04034b50, true) // PK\x03\x04
    offset += 4

    // Version needed (2.0 for normal ZIP)
    headerView.setUint16(offset, 20, true)
    offset += 2

    // General purpose bit flag (0x0000 = no encryption, no UTF-8)
    headerView.setUint16(offset, 0x0000, true)
    offset += 2

    // Compression method (0 = stored, no compression)
    headerView.setUint16(offset, 0, true)
    offset += 2

    // Last mod time & date (current time)
    const now = new Date()
    const dosTime = ((now.getHours() << 11) | (now.getMinutes() << 5) | (now.getSeconds() >> 1))
    const dosDate = (((now.getFullYear() - 1980) << 9) | ((now.getMonth() + 1) << 5) | now.getDate())
    headerView.setUint16(offset, dosTime, true)
    offset += 2
    headerView.setUint16(offset, dosDate, true)
    offset += 2

    // CRC-32
    headerView.setUint32(offset, crc32, true)
    offset += 4

    // Compressed size (same as uncompressed for stored)
    headerView.setUint32(offset, fileBytes.length, true)
    offset += 4

    // Uncompressed size
    headerView.setUint32(offset, fileBytes.length, true)
    offset += 4

    // Filename length
    headerView.setUint16(offset, filenameBytes.length, true)
    offset += 2

    // Extra field length (0)
    headerView.setUint16(offset, 0, true)
    offset += 2

    // Filename
    localHeader.set(filenameBytes, offset)

    // Combine header + file data
    const totalSize = localHeader.length + fileBytes.length
    const newZipData = new Uint8Array(zipData.length + totalSize)
    newZipData.set(zipData)
    newZipData.set(localHeader, zipData.length)
    newZipData.set(fileBytes, zipData.length + localHeader.length)
    zipData = newZipData

    fileEntries.push({
      name: entry.name,
      content: fileBytes,
      crc32,
      localOffset: currentOffset
    })

    currentOffset += totalSize
    console.log(`‚úÖ Added: ${entry.name} (${fileBytes.length} bytes)`)
  }

  // Create central directory
  const centralDirectoryOffset = zipData.length
  let centralDirectorySize = 0

  for (const entry of fileEntries) {
    const filenameBytes = new TextEncoder().encode(entry.name)
    const centralHeader = new Uint8Array(46 + filenameBytes.length)
    const centralView = new DataView(centralHeader.buffer)

    let offset = 0

    // Central file header signature
    centralView.setUint32(offset, 0x02014b50, true)
    offset += 4

    // Version made by (2.0)
    centralView.setUint16(offset, 20, true)
    offset += 2

    // Version needed to extract (2.0)
    centralView.setUint16(offset, 20, true)
    offset += 2

    // General purpose bit flag
    centralView.setUint16(offset, 0x0000, true)
    offset += 2

    // Compression method (0 = stored)
    centralView.setUint16(offset, 0, true)
    offset += 2

    // Last mod time & date
    const now = new Date()
    const dosTime = ((now.getHours() << 11) | (now.getMinutes() << 5) | (now.getSeconds() >> 1))
    const dosDate = (((now.getFullYear() - 1980) << 9) | ((now.getMonth() + 1) << 5) | now.getDate())
    centralView.setUint16(offset, dosTime, true)
    offset += 2
    centralView.setUint16(offset, dosDate, true)
    offset += 2

    // CRC-32
    centralView.setUint32(offset, entry.crc32, true)
    offset += 4

    // Compressed size
    centralView.setUint32(offset, entry.content.length, true)
    offset += 4

    // Uncompressed size
    centralView.setUint32(offset, entry.content.length, true)
    offset += 4

    // Filename length
    centralView.setUint16(offset, filenameBytes.length, true)
    offset += 2

    // Extra field length
    centralView.setUint16(offset, 0, true)
    offset += 2

    // File comment length
    centralView.setUint16(offset, 0, true)
    offset += 2

    // Disk number start
    centralView.setUint16(offset, 0, true)
    offset += 2

    // Internal file attributes
    centralView.setUint16(offset, 0, true)
    offset += 2

    // External file attributes
    centralView.setUint32(offset, 0x81A40000, true)
    offset += 4

    // Relative offset of local header
    centralView.setUint32(offset, entry.localOffset, true)
    offset += 4

    // Filename
    centralHeader.set(filenameBytes, offset)

    // Append to ZIP
    const newZipData = new Uint8Array(zipData.length + centralHeader.length)
    newZipData.set(zipData)
    newZipData.set(centralHeader, zipData.length)
    zipData = newZipData

    centralDirectorySize += centralHeader.length
  }

  // End of central directory record
  const endRecord = new Uint8Array(22)
  const endView = new DataView(endRecord.buffer)

  endView.setUint32(0, 0x06054b50, true) // Signature
  endView.setUint16(4, 0, true) // This disk number
  endView.setUint16(6, 0, true) // Central directory start disk
  endView.setUint16(8, fileEntries.length, true) // Entries this disk
  endView.setUint16(10, fileEntries.length, true) // Total entries
  endView.setUint32(12, centralDirectorySize, true) // Central directory size
  endView.setUint32(16, centralDirectoryOffset, true) // Central directory offset
  endView.setUint16(20, 0, true) // Comment length

  // Final ZIP
  const finalZipData = new Uint8Array(zipData.length + endRecord.length)
  finalZipData.set(zipData)
  finalZipData.set(endRecord, zipData.length)

  console.log(`‚úÖ Simple .at package created: ${finalZipData.length} bytes`)

  return finalZipData.buffer
}

// Handler for simple .at package generation
export async function handleATGenerate(request: Request, env: any): Promise<Response> {
  console.log('üì¶ Simple .at package generation requested')

  try {
    const body = await request.json() as { device_hash: string }
    const { device_hash } = body

    if (!device_hash) {
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Device hash is required'
        }),
        {
          status: 400,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
          }
        }
      )
    }

    console.log(`üì± Generating simple .at for device: ${device_hash}`)

    const atBuffer = await createSimpleAT(device_hash)

    console.log(`‚úÖ Sending .at package: ${atBuffer.byteLength} bytes`)

    // Return .at file (for AutoTouch to encrypt)
    return new Response(atBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/zip',
        'Content-Disposition': 'attachment; filename="smartgram_simple.at"',
        'Access-Control-Allow-Origin': '*'
      }
    })

  } catch (error) {
    console.error('‚ùå AT generation error:', error)
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      }),
      {
        status: 500,
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*'
        }
      }
    )
  }
}